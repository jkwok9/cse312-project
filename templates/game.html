<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Territory Claim (Multiplayer)</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.5/socket.io.min.js"></script>
    <style>
        /* CSS Styles (same as previous version) */
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background-color: #1a1a1a; /* Dark background */
            color: #fff; /* White text */
            font-family: 'Press Start 2P', cursive;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
        }

        h1 {
            color: #ffff00; /* Yellow title */
            margin-bottom: 10px;
            text-shadow: 2px 2px #ff00ff; /* Magenta shadow */
        }

        canvas {
            border: 5px solid #fff; /* White border */
            background-color: #333; /* Dark grey grid background */
            display: block; /* Prevents extra space below canvas */
            margin-bottom: 20px;
            max-width: 100%; /* Ensure canvas fits smaller screens */
            height: auto; /* Maintain aspect ratio */
            image-rendering: pixelated; /* Keep pixels sharp */
            border-radius: 8px; /* Rounded corners */
        }

        .game-info {
            display: flex;
            justify-content: center;
            width: 100%;
            max-width: 800px; /* Increased width */
            margin-bottom: 15px;
            flex-wrap: wrap; /* Wrap scores on smaller screens */
            gap: 10px;
        }

        .info-box {
            background-color: #444; /* Slightly lighter grey */
            padding: 10px 15px;
            border-radius: 8px;
            border: 2px solid #fff;
            text-align: center;
            box-shadow: 3px 3px 0px rgba(0, 0, 0, 0.5);
            margin: 5px;
            min-width: 150px;
        }

        .info-box span {
            display: block;
            font-size: 1.2em;
            margin-top: 5px;
        }

        #timer {
            font-size: 1.5em;
            color: #ff851b; /* Orange */
        }

        #status {
            font-size: 1.2em;
            color: #ffff00; /* Yellow */
            margin-bottom: 15px;
            min-height: 1.5em; /* Reserve space */
            text-align: center;
        }
         /* Highlight current player */
        .my-player-indicator {
            font-weight: bold;
            border: 2px solid yellow; /* Highlight box of the current player */
            box-shadow: 0 0 10px yellow;
        }


        .controls, .instructions {
            background-color: #2a2a2a;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            border: 2px dashed #aaa;
            width: 100%;
            max-width: 800px; /* Increased width */
            text-align: center;
        }
        .controls h2, .instructions h2 {
            margin-top: 0;
            color: #7fdbff; /* Aqua */
            margin-bottom: 10px;
        }
         .controls p, .instructions p {
            margin: 5px 0;
            line-height: 1.6;
         }

        button {
            font-family: 'Press Start 2P', cursive;
            font-size: 1em;
            padding: 15px 30px;
            background: linear-gradient(145deg, #5a5a5a, #3a3a3a); /* Grey gradient */
            color: #fff;
            border: 3px solid #fff;
            border-radius: 10px;
            cursor: pointer;
            text-shadow: 1px 1px #000;
            box-shadow: 4px 4px 0px #000; /* Simple shadow */
            transition: all 0.1s ease;
            margin-top: 10px;
        }

        button:hover {
            background: linear-gradient(145deg, #6a6a6a, #4a4a4a);
            box-shadow: 5px 5px 0px #111;
            transform: translate(-1px, -1px);
        }
        button:active {
            background: linear-gradient(145deg, #3a3a3a, #5a5a5a);
            box-shadow: 2px 2px 0px #000;
            transform: translate(2px, 2px);
        }
         #resetButton {
            display: none; /* Hide reset initially */
         }
         
         /* Reconnect button */
         #reconnectButton {
            display: none; /* Hidden by default */
            margin-bottom: 15px;
            background: linear-gradient(145deg, #4a5a4a, #3a4a3a); /* Green-ish gradient */
         }

        /* New style for welcome message */
        .welcome-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            max-width: 800px; /* Increased width */
            margin-bottom: 15px;
        }

        .welcome-message {
            color: #7fdbff; /* Aqua blue */
            font-size: 1em;
            text-shadow: 1px 1px #000;
        }

        /* Logout button style */
        #logoutButton {
            background: linear-gradient(145deg, #aa3030, #771515); /* Red gradient */
            padding: 10px 20px;
            font-size: 0.8em;
        }

        #logoutButton:hover {
            background: linear-gradient(145deg, #cc3030, #881515);
        }
        
        /* Players list styles */
        .players-list {
            display: flex;
            flex-direction: column;
            max-height: 200px;
            overflow-y: auto;
            width: 100%;
            max-width: 800px;
            background-color: #2a2a2a;
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 15px;
        }
        
        .players-list-title {
            text-align: center;
            color: #7fdbff;
            margin-bottom: 10px;
        }
        
        .player-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }
        
        .player-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin-right: 10px;
            border: 2px solid #fff;
        }
        
        .player-name {
            flex-grow: 1;
        }
        
        .player-score {
            margin-left: 10px;
            font-weight: bold;
        }
    </style>
</head>
<body>

    <h1>Territory Claim! (Multiplayer)</h1>

    <!-- New: Welcome message and logout button -->
    <div class="welcome-container">
        <div class="welcome-message">Welcome <span id="username">Player</span>!</div>
        <a href="/logout"><button id="logoutButton">Logout</button></a>
    </div>

    <canvas id="gameCanvas"></canvas>

    <div class="game-info">
        <div class="info-box">Time: <span id="timer">--:--</span></div>
        <!-- Player boxes will be dynamically added here -->
    </div>

    <div id="status">Connecting to server...</div>
    
    <!-- Players list container -->
    <div class="players-list">
        <div class="players-list-title">ACTIVE PLAYERS</div>
        <div id="playersList">
            <!-- Player items will be dynamically added here -->
        </div>
    </div>
    
    <!-- Reconnect button -->
    <button id="reconnectButton">Reconnect to Server</button>

    <div class="instructions">
        <h2>Instructions</h2>
        <p>Move your player to claim territory. The floor turns your color! The player with the most territory wins.</p>
    </div>

    <div class="controls">
        <h2>Controls</h2>
        <p>Use WASD keys to move YOUR player.</p>
    </div>

    <button id="resetButton">Request Reset</button>

    <script>
        // --- Game Configuration ---
        const GRID_SIZE = 40; // Larger grid
        const DEFAULT_CELL_COLOR = '#333'; // Dark grey grid background
        const GRID_LINE_COLOR = '#555'; // Slightly lighter grey for lines
        const PLAYER_SIZE_FACTOR = 0.7; // How much of a cell the player circle occupies

        // Player Controls Mapping
        const MOVEMENT_KEYS = {
            'KeyW': { dx: 0, dy: -1 }, // Up
            'KeyS': { dx: 0, dy: 1 },  // Down
            'KeyA': { dx: -1, dy: 0 }, // Left
            'KeyD': { dx: 1, dy: 0 }   // Right
        };

        // --- Rate Limiting ---
        const MOVE_DELAY = 100; // Milliseconds - Minimum delay between moves (Adjust as needed)
        let lastMoveTime = 0;   // Timestamp of the last emitted move

        // --- DOM Elements ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameInfoContainer = document.querySelector('.game-info');
        const timerElement = document.getElementById('timer');
        const statusElement = document.getElementById('status');
        const resetButton = document.getElementById('resetButton');
        const reconnectButton = document.getElementById('reconnectButton');
        const usernameElement = document.getElementById('username');
        const playersListContainer = document.getElementById('playersList');

        // --- Game State (Client-Side Mirror) ---
        let grid = [];
        let players = [];
        let myPlayerId = null;
        let gameActive = false;
        let cellSize = 0;
        let isConnected = false;
        let socket = null;
        let playerColors = {}; // Map of player IDs to colors
        
        // Helper function to show status messages
        function showMessage(message) {
            statusElement.textContent = message;
        }

        // Initialize canvas on page load
        window.addEventListener('load', initCanvas);
        window.addEventListener('resize', initCanvas);

        function initCanvas() {
            const availableWidth = Math.min(window.innerWidth * 0.9, 800); // Increased max width
            const availableHeight = Math.min(window.innerHeight * 0.6, 800); // Increased max height
            const minDimension = Math.min(availableWidth, availableHeight);
            cellSize = Math.floor(minDimension / GRID_SIZE);
            canvas.width = GRID_SIZE * cellSize;
            canvas.height = GRID_SIZE * cellSize;
            
            // Draw empty grid initially
            ctx.fillStyle = DEFAULT_CELL_COLOR;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    ctx.strokeStyle = GRID_LINE_COLOR;
                    ctx.lineWidth = 1;
                    ctx.strokeRect(x * cellSize, y * cellSize, cellSize, cellSize);
                }
            }
        }

        function drawGame() {
            if (!grid || grid.length === 0) return;

            ctx.fillStyle = DEFAULT_CELL_COLOR;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    if (grid[y] && grid[y][x] !== undefined && grid[y][x] !== null && grid[y][x] !== -1) {
                        const ownerId = grid[y][x];
                        if (playerColors[ownerId]) {
                            ctx.fillStyle = playerColors[ownerId];
                            ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                        }
                    }
                    ctx.strokeStyle = GRID_LINE_COLOR;
                    ctx.lineWidth = 1;
                    ctx.strokeRect(x * cellSize, y * cellSize, cellSize, cellSize);
                }
            }

            const playerRadius = (cellSize * PLAYER_SIZE_FACTOR) / 2;
            players.forEach(player => {
                if (player && player.id !== undefined && playerColors[player.id]) {
                    // Draw player circle
                    ctx.fillStyle = playerColors[player.id];
                    ctx.beginPath();
                    ctx.arc(
                        player.x * cellSize + cellSize / 2,
                        player.y * cellSize + cellSize / 2,
                        playerRadius,
                        0,
                        Math.PI * 2
                    );
                    ctx.fill();
                    
                    // Draw username with shadow for visibility
                    ctx.fillStyle = '#ffffff';
                    ctx.font = `${Math.max(10, cellSize/3)}px 'Press Start 2P'`; // Dynamic font size
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'top';
                    
                    // Text shadow
                    ctx.shadowColor = '#000000';
                    ctx.shadowBlur = 3;
                    
                    ctx.fillText(
                        player.username || `Player ${player.id}`,
                        player.x * cellSize + cellSize / 2,
                        player.y * cellSize + cellSize / 2 + playerRadius + 2
                    );
                    
                    // Reset shadow
                    ctx.shadowBlur = 0;
                }
            });
        }

        function updatePlayersList() {
            // Sort players by score (descending)
            const sortedPlayers = [...players].sort((a, b) => {
                // If player has a score field, use it, otherwise default to 0
                const scoreA = a.score !== undefined ? a.score : 0;
                const scoreB = b.score !== undefined ? b.score : 0;
                return scoreB - scoreA; // Descending order
            });
            
            // Clear the current list
            playersListContainer.innerHTML = '';
            
            // Add each player to the list
            sortedPlayers.forEach(player => {
                if (!player || player.id === undefined) return;
                
                const playerItem = document.createElement('div');
                playerItem.className = 'player-item';
                if (player.id === myPlayerId) {
                    playerItem.style.fontWeight = 'bold';
                }
                
                const colorCircle = document.createElement('div');
                colorCircle.className = 'player-color';
                colorCircle.style.backgroundColor = playerColors[player.id] || '#fff';
                
                const playerName = document.createElement('div');
                playerName.className = 'player-name';
                playerName.textContent = player.username || `Player ${player.id}`;
                
                const playerScore = document.createElement('div');
                playerScore.className = 'player-score';
                playerScore.textContent = player.score !== undefined ? player.score : '0';
                
                playerItem.appendChild(colorCircle);
                playerItem.appendChild(playerName);
                playerItem.appendChild(playerScore);
                
                playersListContainer.appendChild(playerItem);
            });
        }

        function updatePlayerHighlight() {
            // Remove any existing player indicators
            document.querySelectorAll('.info-box').forEach(box => {
                box.classList.remove('my-player-indicator');
            });
            
            // Find and highlight the current player's box if it exists
            if (myPlayerId !== null) {
                const myBox = document.getElementById(`infobox-${myPlayerId}`);
                if (myBox) {
                    myBox.classList.add('my-player-indicator');
                }
            }
        }

        // Function to handle key presses for movement
        function handleKeyDown(event) {
            if (!gameActive || myPlayerId === null || !isConnected) return;
            
            const move = MOVEMENT_KEYS[event.code];
            if (move) {
                const now = Date.now();
                
                if (now - lastMoveTime > MOVE_DELAY) {
                    socket.emit('player_move', { dx: move.dx, dy: move.dy });
                    lastMoveTime = now;
                }
            }
        }

        // Initialize the game when the page loads
        document.addEventListener('DOMContentLoaded', function() {
            initCanvas();
            connectToServer();
            
            // Set up event listeners
            window.addEventListener('keydown', handleKeyDown);
            
            // Reset button
            resetButton.addEventListener('click', function() {
                if (isConnected) {
                    socket.emit('request_reset');
                }
            });
            
            // Reconnect button
            reconnectButton.addEventListener('click', function() {
                connectToServer();
            });
        });

        // Establish socket connection
        function connectToServer() {
            // Display connecting message
            showMessage('Connecting to server...');
            reconnectButton.style.display = 'none';
            
            // Clean up existing socket if there is one
            if (socket) {
                socket.disconnect();
                socket = null;
            }
            
            // Create a new socket
            socket = io(window.location.origin, {
                transports: ['polling'],  // Use polling only - NO WebSocket
                upgrade: false,           // Disable transport upgrades
                reconnection: true,
                reconnectionAttempts: 5,
                reconnectionDelay: 1000
            });
            
            // Connection event
            socket.on('connect', function() {
                console.log('Connected to server with ID:', socket.id);
                showMessage('Connected! Waiting for game to start...');
                isConnected = true;
                reconnectButton.style.display = 'none';
            });
            
            // Disconnection event
            socket.on('disconnect', function() {
                console.log('Disconnected from server');
                showMessage('Disconnected from server. Click reconnect to try again.');
                isConnected = false;
                reconnectButton.style.display = 'inline-block';
            });
            
            // Connection error
            socket.on('connect_error', function(error) {
                console.error('Connection error:', error);
                showMessage('Error connecting to server');
                isConnected = false;
                reconnectButton.style.display = 'inline-block';
            });
            
            // Game events
            socket.on('assign_player', function(data) {
                myPlayerId = data.playerId;
                console.log(`Assigned Player ID: ${myPlayerId}`);
                showMessage(`You are Player ${myPlayerId}! Game in progress...`);
                updatePlayerHighlight();
            });
            
            socket.on('game_update', function(serverState) {
                grid = serverState.grid;
                players = serverState.players;
                gameActive = serverState.game_active;
                
                // Update color map
                playerColors = {};
                players.forEach(player => {
                    if (player && player.id !== undefined && player.color) {
                        playerColors[player.id] = player.color;
                    }
                });
                
                updateTimerDisplay(serverState.remaining_time);
                updatePlayersList();
                drawGame();
                
                // Update username in welcome message if available
                if (players && players.length > 0) {
                    for (let i = 0; i < players.length; i++) {
                        if (players[i] && players[i].id === myPlayerId && players[i].username) {
                            usernameElement.textContent = players[i].username;
                            break;
                        }
                    }
                }
            });
            
            socket.on('game_event', function(data) {
                console.log("Game Event:", data.message);
                showMessage(data.message);
                if (data.isGameOver) {
                    resetButton.style.display = 'inline-block';
                } else {
                    resetButton.style.display = 'none';
                }
            });
            
            socket.on('game_reset', function(initialState) {
                console.log("Game Reset by Server.");
                showMessage('Game Reset! Waiting for players...');
                myPlayerId = null;
                grid = initialState.grid;
                players = initialState.players;
                gameActive = initialState.game_active;
                
                // Update color map
                playerColors = {};
                players.forEach(player => {
                    if (player && player.id !== undefined && player.color) {
                        playerColors[player.id] = player.color;
                    }
                });
                
                updateTimerDisplay(initialState.remaining_time);
                updatePlayersList();
                updatePlayerHighlight();
                resetButton.style.display = 'none';
                drawGame();
            });
            
            // Redirect event
            socket.on('redirect', function(data) {
                if (data.url) {
                    console.log('Redirecting to:', data.url);
                    window.location.href = data.url;
                }
            });
        }
        
        function updateTimerDisplay(time) {
             if (typeof time !== 'number') {
                  timerElement.textContent = "--:--";
                  return;
             }
            const minutes = Math.floor(time / 60);
            const seconds = time % 60;
            timerElement.textContent = `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;
        }
        
        // Clean up when the page is unloaded
        window.addEventListener('beforeunload', function() {
            if (socket) {
                socket.disconnect();
                socket = null;
            }
        });
    </script>
</body>
</html>