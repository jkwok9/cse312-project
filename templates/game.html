<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Territory Claim Teams!</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.5/socket.io.min.js"></script>
    <style>
        /* --- Reset & Base --- */
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden; /* Prevent body scrollbars */
        }
        body {
            display: flex;
            flex-direction: column; /* Stack header, main content */
            background-color: #1a1a1a;
            color: #fff;
            font-family: 'Press Start 2P', cursive;
            font-size: 10px; /* Base font size */
        }
        * { box-sizing: border-box; }

        /* --- Header Area --- */
        .header {
            padding: 10px 20px;
            background-color: #111; /* Darker header */
            border-bottom: 2px solid #444;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0; /* Prevent header from shrinking */
        }
        h1 {
            color: #ffff00;
            margin: 0;
            text-shadow: 2px 2px #ff00ff;
            font-size: 1.8em; /* Adjusted size */
        }
        .welcome-message { color: #7fdbff; font-size: 1.1em; text-shadow: 1px 1px #000; white-space: nowrap; margin-left: 20px;}
        #logoutButton { background: linear-gradient(145deg, #aa3030, #771515); padding: 6px 12px; font-size: 0.8em; margin-left: 15px; }
        #logoutButton:hover { background: linear-gradient(145deg, #cc3030, #881515); }

        /* --- Main Content Area (Flex Container) --- */
        #main-content-area {
            display: flex;
            flex-direction: row; /* Canvas | Sidebar */
            flex-grow: 1; /* Take remaining vertical space */
            width: 100%;
            overflow: hidden; /* Prevent overflow within main area */
            align-items: stretch; /* Explicitly ensure children stretch vertically (default) */
        }

        /* --- Canvas Container (Left Side) --- */
        #canvas-container {
            flex-grow: 1; /* Allow canvas area to expand */
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 15px; /* Spacing around the canvas */
            overflow: hidden; /* Hide any minor overflow */
            background-color: #252525; /* Slightly different bg */
        }
        canvas#gameCanvas {
            display: block;
            border: 4px solid #fff;
            background-color: #333;
            max-width: 100%;   /* Fill container width */
            max-height: 100%;  /* Fill container height */
            object-fit: contain; /* Maintain aspect ratio */
            image-rendering: pixelated;
            border-radius: 8px;
            /* Width/Height set by JS, aspect ratio handled there */
        }

        /* --- Sidebar (Right Side) --- */
        #sidebar {
            width: 300px; /* Fixed width for sidebar */
            flex-shrink: 0; /* Prevent sidebar from shrinking */
            padding: 15px;
            background-color: #2a2a2a;
            border-left: 2px solid #444;
            display: flex;
            flex-direction: column;
            gap: 10px; /* Space between sidebar items */
            overflow-y: auto; /* Allow sidebar scrolling if content overflows */
            /* height: 100%; Removed this, rely on align-items: stretch from parent */
        }

        /* --- Sidebar Elements Styling --- */
        .info-box { background-color: #444; padding: 8px 12px; border-radius: 6px; border: 2px solid #fff; text-align: center; box-shadow: 2px 2px 0px rgba(0, 0, 0, 0.5); font-size: 1.0em; /* Adjusted size */ width: 100%; }
        .info-box span { display: block; font-size: 1.1em; /* Adjusted size */ margin-top: 4px; font-weight: bold; }
        #timer-box span { color: #ff851b; font-size: 1.4em; /* Adjusted size */ }
        .team-scores { display: flex; flex-direction: column; gap: 4px; /* Adjusted gap */ }
        .team-score-item { display: flex; align-items: center; justify-content: space-between; width: 100%; text-align: left; font-size: 0.9em; /* Adjusted size */ }
        .team-color-box { width: 12px; height: 12px; border: 1px solid #fff; margin-right: 6px; display: inline-block; vertical-align: middle; flex-shrink: 0; }
        .team-name { flex-grow: 1; margin-right: 6px; }
        .team-score-value { font-weight: bold; }

        #status { font-size: 1.2em; /* Adjusted size */ color: #ffff00; min-height: 1.3em; text-align: center; width: 100%; background-color: #3a3a3a; padding: 5px; border-radius: 4px;}

        .players-list-container { background-color: #3a3a3a; padding: 8px; border-radius: 6px; border: 2px dashed #aaa; width: 100%; flex-shrink: 0; /* Prevent shrinking */ max-height: 200px; /* Limit height */ display: flex; flex-direction: column;}
        .players-list-title { text-align: center; color: #7fdbff; margin-bottom: 8px; font-size: 1.1em; /* Adjusted size */ flex-shrink: 0;}
        #playersList { display: flex; flex-direction: column; gap: 4px; /* Adjusted gap */ overflow-y: auto; flex-grow: 1; /* Allow list to take space */ }
        .player-item { display: flex; align-items: center; font-size: 0.9em; /* Adjusted size */ }
        .player-color-box { width: 12px; height: 12px; border: 1px solid #fff; margin-right: 6px; flex-shrink: 0; }
        .player-name { flex-grow: 1; margin-right: 8px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;}
        .player-status { font-size: 0.8em; color: #aaa; margin-left: 4px; flex-shrink: 0;}
        .my-player { font-weight: bold; color: #ffff00; }

        .button-container { text-align: center; width: 100%; display: flex; justify-content: center; gap: 10px; flex-wrap: wrap;} /* Centered buttons */

        .instructions, .controls { background-color: #3a3a3a; padding: 8px; border-radius: 6px; margin-bottom: 0; /* Remove bottom margin */ border: 2px dashed #aaa; width: 100%; text-align: center; flex-shrink: 0; }
        .instructions h2, .controls h2 { margin-top: 0; color: #7fdbff; margin-bottom: 6px; font-size: 1.1em; /* Adjusted size */ }
        .controls p, .instructions p { margin: 4px 0; line-height: 1.4; font-size: 0.9em; /* Adjusted size */ }

        button {
            font-family: 'Press Start 2P', cursive; font-size: 0.9em; /* Adjusted size */ padding: 8px 15px; /* Adjusted padding */
            background: linear-gradient(145deg, #5a5a5a, #3a3a3a); color: #fff; border: 2px solid #fff;
            border-radius: 6px; cursor: pointer; text-shadow: 1px 1px #000; box-shadow: 2px 2px 0px #000;
            transition: all 0.1s ease; margin: 0; /* Removed specific margins */
        }
        button:hover:not(:disabled) { background: linear-gradient(145deg, #6a6a6a, #4a4a4a); box-shadow: 3px 3px 0px #111; transform: translate(-1px, -1px); }
        button:active:not(:disabled) { background: linear-gradient(145deg, #3a3a3a, #5a5a5a); box-shadow: 1px 1px 0px #000; transform: translate(1px, 1px); }
        button:disabled { background: #444; color: #888; border-color: #888; cursor: not-allowed; box-shadow: 1px 1px 0px #000; transform: none;}

        #resetButton, #startButton { display: none; } /* Hide initially */
        #startButton { background: linear-gradient(145deg, #30aa30, #157715); }
        #startButton:hover:not(:disabled) { background: linear-gradient(145deg, #30cc30, #158815); }
        #reconnectButton { display: none; background: linear-gradient(145deg, #4a5a4a, #3a4a3a); }

    </style>
</head>
<body>

    <div class="header">
        <h1>Territory Claim Teams!</h1>
        <div style="display: flex; align-items: center;"> <div class="welcome-message">Welcome <span id="username">Player</span>!</div>
            <a href="/logout"><button id="logoutButton">Logout</button></a>
        </div>
    </div>

    <div id="main-content-area">
        <div id="canvas-container">
            <canvas id="gameCanvas"></canvas>
        </div>

        <div id="sidebar">
            <div class="info-box" id="timer-box">Time Left: <span id="timer">--:--</span></div>

            <div class="info-box team-scores">
                <div style="font-weight:bold; margin-bottom: 5px; text-align:center; color:#7fdbff;">TEAM SCORES</div>
                <div id="teamScoresDisplay"></div>
            </div>

            <div id="status">Connecting to server...</div>

             <div class="button-container">
                 <button id="startButton">Start Game</button>
                 <button id="reconnectButton">Reconnect</button>
                 <button id="resetButton">Request Reset</button>
            </div>

            <div class="players-list-container">
                <div class="players-list-title">ACTIVE PLAYERS</div>
                <div id="playersList"></div>
            </div>

            <div class="instructions">
                <h2>Instructions</h2>
                <p>Use WASD to move & claim. Press "Start Game" when {MIN_PLAYERS_PLACEHOLDER} players join!</p>
                 <p style="color:#aaa; font-size: 0.8em;">Spectate if joining mid-game.</p>
            </div>

            <div class="controls">
                <h2>Controls</h2>
                <p>WASD keys to move.</p>
            </div>
        </div> </div> <script>
        // --- Game Configuration (Client-Side) ---
        const GRID_SIZE = 60; // Must match server
        const DEFAULT_CELL_COLOR = '#333';
        const GRID_LINE_COLOR = '#555';
        const PLAYER_SIZE_FACTOR = 0.7;
        const MOVE_DELAY = 100; // ms between move emits

        // --- Team Colors (Must match server) ---
        const TEAM_COLORS = {
             0: '#FF0000', 1: '#0000FF', 2: '#00FF00', 3: '#FFFF00'
        };
        const DEFAULT_SPECTATOR_COLOR = '#888888'; // Grey

        const MOVEMENT_KEYS = {
            'KeyW': { dx: 0, dy: -1 }, 'KeyS': { dx: 0, dy: 1 },
            'KeyA': { dx: -1, dy: 0 }, 'KeyD': { dx: 1, dy: 0 }
        };

        // --- DOM Elements ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const canvasContainer = document.getElementById('canvas-container'); // Added
        const timerElement = document.getElementById('timer');
        const statusElement = document.getElementById('status');
        const startButton = document.getElementById('startButton');
        const resetButton = document.getElementById('resetButton');
        const reconnectButton = document.getElementById('reconnectButton');
        const usernameElement = document.getElementById('username');
        const playersListContainer = document.getElementById('playersList');
        const teamScoresDisplay = document.getElementById('teamScoresDisplay');
        const instructionsElement = document.querySelector('.instructions p:first-child');


        // --- Client Game State ---
        let grid = [];
        let players = [];
        let teams = {};
        let myPlayerId = null;
        let myPlayerData = null;
        let gameActive = false;
        let isSpectator = false;
        let cellSize = 0;
        let isConnected = false;
        let socket = null;
        let lastMoveTime = 0;
        let minPlayersToStart = 2; // Default, will be updated from server

        // --- Helper Functions ---
        function showMessage(message, isError = false) {
            statusElement.textContent = message;
            statusElement.style.color = isError ? '#FF5555' : '#FFFF00';
        }

        function updateTimerDisplay(time) {
            if (typeof time !== 'number' || time < 0) {
                timerElement.textContent = "--:--"; return;
            }
            const minutes = Math.floor(time / 60);
            const seconds = time % 60;
            timerElement.textContent = `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;
        }

        // --- Canvas Initialization and Drawing (MODIFIED) ---
        function initCanvas() {
            // Get dimensions of the container DIV, not the window
            const containerWidth = canvasContainer.offsetWidth;
            const containerHeight = canvasContainer.offsetHeight;

            // Subtract padding/border if you want canvas edge-to-edge with container border
            const availableWidth = containerWidth - 30; // approx padding * 2
            const availableHeight = containerHeight - 30; // approx padding * 2

            // Calculate cell size based on fitting GRID_SIZE into the smaller dimension
            const sizeBasedOnWidth = Math.floor(availableWidth / GRID_SIZE);
            const sizeBasedOnHeight = Math.floor(availableHeight / GRID_SIZE);
            cellSize = Math.max(1, Math.min(sizeBasedOnWidth, sizeBasedOnHeight)); // Ensure at least 1px

            // Calculate the actual canvas dimensions
            const canvasWidth = GRID_SIZE * cellSize;
            const canvasHeight = GRID_SIZE * cellSize;

            // Set the canvas drawing buffer size
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;

            // // Keep CSS sizing for layout if needed, but drawing buffer is now correct
            // canvas.style.width = `${canvasWidth}px`;
            // canvas.style.height = `${canvasHeight}px`;
             // Let CSS handle the display size via max-width/max-height in #canvas-container

            console.log(`Canvas Init: Container(${containerWidth}x${containerHeight}), CellSize: ${cellSize}, Canvas(${canvasWidth}x${canvasHeight})`);

            drawGame(); // Redraw with new size
        }

        function drawGame() {
            if (cellSize <= 0) { /* console.warn("Cell size not positive, skipping draw."); */ return; } // Less noisy log

            ctx.fillStyle = DEFAULT_CELL_COLOR;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw Grid Cells & Lines
            if (grid && grid.length > 0) {
                for (let y = 0; y < GRID_SIZE; y++) {
                    for (let x = 0; x < GRID_SIZE; x++) {
                        const teamId = grid[y]?.[x];
                        if (teamId !== undefined && teamId !== null && teamId !== -1) {
                            ctx.fillStyle = TEAM_COLORS[teamId] || DEFAULT_CELL_COLOR;
                            ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                        }
                        // Draw Grid Lines (optional, can clutter)
                        if (cellSize > 4) { // Only draw if cells are big enough
                           ctx.strokeStyle = GRID_LINE_COLOR;
                           ctx.lineWidth = 0.5;
                           ctx.strokeRect(x * cellSize, y * cellSize, cellSize, cellSize);
                        }
                    }
                }
            } else { /* Draw empty grid lines if needed, or just leave default bg */ }

            // Draw Players & Usernames
            const playerRadius = (cellSize * PLAYER_SIZE_FACTOR) / 2;
             // Limit username size to avoid excessive overlap
             const maxFontSize = 22;
             const minFontSize = 10;
             const fontSize = Math.max(minFontSize, Math.min(maxFontSize, Math.floor(cellSize / 3.0)));

            players.forEach(player => {
                if (player && player.id !== undefined && player.x >= 0 && player.y >= 0) {
                    const playerColor = TEAM_COLORS[player.team_id] ?? DEFAULT_SPECTATOR_COLOR;
                    const playerCenterX = player.x * cellSize + cellSize / 2;
                    const playerCenterY = player.y * cellSize + cellSize / 2;

                    // Player Circle
                    ctx.fillStyle = playerColor;
                    ctx.beginPath(); ctx.arc(playerCenterX, playerCenterY, playerRadius, 0, Math.PI * 2); ctx.fill();

                    // Outline
                    ctx.strokeStyle = (player.id === myPlayerId && !isSpectator) ? '#FFFFFF' : '#000000';
                    ctx.lineWidth = (player.id === myPlayerId && !isSpectator) ? Math.max(1, Math.floor(cellSize * 0.05)) : 1; // Scale outline slightly
                    ctx.stroke();

                    // Draw Username (only if cell size allows)
                    if (cellSize > 8) {
                        ctx.font = `${fontSize}px 'Press Start 2P'`;
                        ctx.fillStyle = '#FFFFFF'; ctx.textAlign = 'center'; ctx.textBaseline = 'bottom'; // Draw below center
                        ctx.shadowColor = '#000000'; ctx.shadowBlur = 2;
                         // Truncate long names
                        const maxNameLength = 10;
                        const displayName = (player.username || `P${player.id}`).length > maxNameLength
                            ? player.username.substring(0, maxNameLength - 1) + '…'
                            : player.username || `P${player.id}`;

                        ctx.fillText( displayName, playerCenterX, playerCenterY - playerRadius - 2 ); // Position above circle slightly
                        ctx.shadowBlur = 0;
                    }
                }
            });
        }


        // --- UI Update Functions ---
        function updateTeamScores() {
            teamScoresDisplay.innerHTML = '';
            if (!teams || Object.keys(teams).length === 0) return;
            const sortedTeamIds = Object.keys(teams).sort((a, b) => a - b);
            sortedTeamIds.forEach(tid => {
                const team = teams[tid]; if (!team) return;
                const item = document.createElement('div'); item.className = 'team-score-item';
                const colorBox = document.createElement('span'); colorBox.className = 'team-color-box'; colorBox.style.backgroundColor = team.color || '#ccc';
                const nameSpan = document.createElement('span'); nameSpan.className = 'team-name'; nameSpan.textContent = team.name || `Team ${tid}`;
                const scoreSpan = document.createElement('span'); scoreSpan.className = 'team-score-value'; scoreSpan.textContent = team.score !== undefined ? team.score : '0';
                item.appendChild(colorBox); item.appendChild(nameSpan); item.appendChild(scoreSpan);
                teamScoresDisplay.appendChild(item);
            });
        }

        function updatePlayersList() {
            playersListContainer.innerHTML = ''; // Clear only the list, not the title
            if (!players || players.length === 0) return;

             // Re-add title if needed, or adjust structure so title isn't cleared
             // const titleElement = document.createElement('div');
             // titleElement.className = 'players-list-title';
             // titleElement.textContent = 'ACTIVE PLAYERS';
             // playersListContainer.appendChild(titleElement); // If clearing the whole container

            const sortedPlayers = [...players].sort((a, b) => (a.username?.toLowerCase() || '').localeCompare(b.username?.toLowerCase() || ''));
            sortedPlayers.forEach(player => {
                if (!player || player.id === undefined) return;
                const playerItem = document.createElement('div'); playerItem.className = 'player-item';
                const colorBox = document.createElement('div'); colorBox.className = 'player-color-box'; colorBox.style.backgroundColor = TEAM_COLORS[player.team_id] ?? DEFAULT_SPECTATOR_COLOR;
                const playerName = document.createElement('div'); playerName.className = 'player-name'; playerName.textContent = player.username || `Player ${player.id}`;
                if (player.id === myPlayerId) { playerName.classList.add('my-player'); }
                playerItem.appendChild(colorBox); playerItem.appendChild(playerName);
                if (player.is_spectator) {
                    const statusSpan = document.createElement('span'); statusSpan.className = 'player-status'; statusSpan.textContent = '(Spec)'; // Shorter
                    playerItem.appendChild(statusSpan);
                }
                playersListContainer.appendChild(playerItem); // Append to the list container
            });
        }

        // --- Input Handling ---
        function handleKeyDown(event) {
            if (!isConnected || myPlayerId === null || isSpectator || !gameActive) return;
            const move = MOVEMENT_KEYS[event.code];
            if (move) {
                event.preventDefault();
                const now = Date.now();
                if (now - lastMoveTime > MOVE_DELAY) {
                    socket.emit('player_move', { dx: move.dx, dy: move.dy });
                    lastMoveTime = now;
                }
            }
        }


        // --- SocketIO Connection and Event Handlers ---
        function connectToServer() {
            showMessage('Connecting...');
            reconnectButton.style.display = 'none';
            startButton.style.display = 'none';
            resetButton.style.display = 'none';
            if (socket) { socket.disconnect(); socket = null; }
            socket = io(window.location.origin, { reconnection: true, reconnectionAttempts: 5, reconnectionDelay: 1000, });

            socket.on('connect', () => {
                console.log('Connected. SID:', socket.id);
                isConnected = true;
                showMessage('Connected! Waiting...');
                reconnectButton.style.display = 'none';
            });
            socket.on('disconnect', (reason) => {
                console.log('Disconnected. Reason:', reason);
                isConnected = false; showMessage('Disconnected!', true);
                reconnectButton.style.display = 'inline-block';
                startButton.style.display = 'none'; resetButton.style.display = 'none';
                gameActive = false; myPlayerData = null; isSpectator = false;
            });
            socket.on('connect_error', (error) => {
                console.error('Connection Error:', error);
                isConnected = false; showMessage(`Connect Fail!`, true);
                reconnectButton.style.display = 'inline-block';
                startButton.style.display = 'none'; resetButton.style.display = 'none';
                gameActive = false;
            });
            socket.on('assign_player', (data) => {
                myPlayerId = data.playerId; isSpectator = data.isSpectator || false;
                console.log(`Assigned PID: ${myPlayerId}, Spectator: ${isSpectator}`);
            });

            socket.on('game_update', (serverState) => {
                grid = serverState.grid; players = serverState.players; teams = serverState.teams;
                gameActive = serverState.game_active;
                minPlayersToStart = serverState.min_players_to_start || 2;
                const activePlayersCount = serverState.active_players_count || 0;

                myPlayerData = players.find(p => p.id === myPlayerId);
                if (myPlayerData) {
                    isSpectator = myPlayerData.is_spectator;
                    usernameElement.textContent = myPlayerData.username || 'Player';
                    if (isSpectator && gameActive) { showMessage("Spectating..."); }
                    else if (!gameActive) { showMessage(`Waiting (${activePlayersCount}/${minPlayersToStart})...`); }
                    else { showMessage(""); } // Playing
                } else {
                    usernameElement.textContent = 'Player'; isSpectator = false;
                    if (!gameActive) showMessage(`Waiting (${activePlayersCount}/${minPlayersToStart})...`); else showMessage("");
                }

                updateTimerDisplay(serverState.remaining_time); updateTeamScores(); updatePlayersList(); drawGame();

                const canStart = !gameActive && activePlayersCount >= minPlayersToStart;
                startButton.style.display = (isConnected && !gameActive) ? 'inline-block' : 'none'; // Show if connected & inactive
                startButton.disabled = !canStart; // Enable only if enough players

                resetButton.style.display = (isConnected && !gameActive) ? 'inline-block' : 'none'; // Show Reset only if inactive & connected
                resetButton.disabled = gameActive;

                if(instructionsElement) {
                    instructionsElement.textContent = `Use WASD to move & claim. Press "Start Game" when ${minPlayersToStart} players join!`;
                }
            });

            socket.on('game_event', (data) => {
                console.log("Event:", data.message);
                 // Prioritize game over message or spectator message
                if (data.isGameOver) { showMessage(data.message); gameActive = false; }
                else if (isSpectator && gameActive) { showMessage("Spectating..."); }
                else { showMessage(data.message); } // Show other messages if not spectating/game over

                 // Button state might be updated by game_update shortly after, but ensure correct state
                 if (data.isGameOver) {
                     startButton.style.display = (isConnected) ? 'inline-block' : 'none'; // Show start if connected
                     startButton.disabled = true; // Needs player check from game_update
                     resetButton.style.display = (isConnected) ? 'inline-block' : 'none'; // Show reset if connected
                     resetButton.disabled = false;
                 }
            });

            socket.on('game_reset', (initialState) => {
                 console.log("Game Reset by Server.");
                 grid = initialState.grid; players = initialState.players; teams = initialState.teams;
                 gameActive = initialState.game_active; minPlayersToStart = initialState.min_players_to_start || 2;
                 const activePlayersCount = initialState.active_players_count || 0;
                 myPlayerData = players.find(p => p.id === myPlayerId);
                 if (myPlayerData) { isSpectator = myPlayerData.is_spectator; usernameElement.textContent = myPlayerData.username || 'Player'; }
                 else { isSpectator = false; }

                 showMessage('Game Reset! Waiting...');
                 updateTimerDisplay(initialState.remaining_time); updateTeamScores(); updatePlayersList(); drawGame();

                 const canStart = !gameActive && activePlayersCount >= minPlayersToStart;
                 startButton.style.display = 'inline-block'; startButton.disabled = !canStart;
                 resetButton.style.display = 'inline-block'; resetButton.disabled = false;
            });

            socket.on('redirect', (data) => { if (data.url) { window.location.href = data.url; } });
        }

        // --- Page Load and Event Listeners ---
        document.addEventListener('DOMContentLoaded', () => {
            // Initial setup before connection
            initCanvas(); // Initial size calculation
            connectToServer();

            window.addEventListener('resize', initCanvas); // Recalculate size on resize
            window.addEventListener('keydown', handleKeyDown);

            startButton.addEventListener('click', () => {
                if (isConnected && !gameActive && !startButton.disabled) {
                    console.log("Requesting game start..."); socket.emit('request_start');
                    startButton.disabled = true; showMessage("Requesting start...");
                }
            });
            resetButton.addEventListener('click', () => {
                if (isConnected && !gameActive) {
                    console.log("Requesting game reset..."); socket.emit('request_reset');
                }
            });
            reconnectButton.addEventListener('click', connectToServer);

             const placeholder = document.querySelector('.instructions p:first-child');
             if(placeholder) { // Initial update before connection info arrives
                 placeholder.textContent = placeholder.textContent.replace('{MIN_PLAYERS_PLACEHOLDER}', minPlayersToStart);
             }
        });
        window.addEventListener('beforeunload', () => { if (socket) { socket.disconnect(); socket = null; } });

    </script>
</body>
</html>